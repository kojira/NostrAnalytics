import { NostrEvent, MetricDataPoint, MetricType } from '../types';
import { initWasm } from '../wasm/analytics';

// Storage key for private key
const PRIVATE_KEY_STORAGE = 'nostr-analytics-private-key';

// WASM module reference
let wasmModule: any = null;

// Initialize WASM module
const ensureWasmLoaded = async () => {
  if (!wasmModule) {
    await initWasm();
    wasmModule = await import('../wasm/pkg/nostr_analytics.js');
  }
  return wasmModule;
};

// Check if NIP-07 extension is available
export const isNostrAvailable = (): boolean => {
  return typeof window !== 'undefined' && !!window.nostr;
};

// Get stored private key
export const getStoredPrivateKey = (): string | null => {
  return localStorage.getItem(PRIVATE_KEY_STORAGE);
};

// Store private key
export const storePrivateKey = (privateKey: string): void => {
  localStorage.setItem(PRIVATE_KEY_STORAGE, privateKey);
};

// Clear stored private key
export const clearPrivateKey = (): void => {
  localStorage.removeItem(PRIVATE_KEY_STORAGE);
};

// Get public key from private key (hex) - using WASM
const getPublicKeyFromPrivate = async (privateKeyHex: string): Promise<string> => {
  const wasm = await ensureWasmLoaded();
  return wasm.get_public_key(privateKeyHex);
};

// Sign event with private key - using nostr-tools (WASM signing is async and complex)
const signEventWithPrivateKey = async (event: NostrEvent, privateKeyHex: string): Promise<NostrEvent> => {
  const { finalizeEvent } = await import('nostr-tools');
  
  const eventToSign = {
    ...event,
    pubkey: await getPublicKeyFromPrivate(privateKeyHex)
  };
  
  // Convert hex string to Uint8Array
  const secretKeyBytes = new Uint8Array(
    privateKeyHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
  );
  
  const signedEvent = finalizeEvent(eventToSign as any, secretKeyBytes);
  
  return signedEvent as NostrEvent;
};

// Get public key (from NIP-07 or stored private key)
export const getPublicKey = async (): Promise<string> => {
  // Try stored private key first
  const storedKey = getStoredPrivateKey();
  if (storedKey) {
    try {
      return await getPublicKeyFromPrivate(storedKey);
    } catch (error) {
      console.error('Failed to derive public key from stored private key:', error);
      clearPrivateKey();
    }
  }
  
  // Fall back to NIP-07
  if (!isNostrAvailable()) {
    throw new Error('Nostr extension (NIP-07) not found and no private key stored.');
  }
  
  try {
    return await window.nostr!.getPublicKey();
  } catch (error) {
    throw new Error(`Failed to get public key: ${error}`);
  }
};

// Sign event (using NIP-07 or stored private key)
export const signEvent = async (event: NostrEvent): Promise<NostrEvent> => {
  // Try stored private key first
  const storedKey = getStoredPrivateKey();
  if (storedKey) {
    try {
      return await signEventWithPrivateKey(event, storedKey);
    } catch (error) {
      console.error('Failed to sign with stored private key:', error);
      throw new Error(`Failed to sign event with private key: ${error}`);
    }
  }
  
  // Fall back to NIP-07
  if (!isNostrAvailable()) {
    throw new Error('Nostr extension (NIP-07) not found and no private key stored.');
  }
  
  try {
    return await window.nostr!.signEvent(event);
  } catch (error) {
    throw new Error(`Failed to sign event: ${error}`);
  }
};

// Create analytics result event (kind: 30080)
export const createAnalyticsEvent = (
  metric: MetricType,
  language: string,
  relays: string[],
  timeframe: {
    start: number;
    end: number;
    windowDays: number;
  },
  counts: MetricDataPoint[],
  eligibleUserCount: number
): NostrEvent => {
  const now = Math.floor(Date.now() / 1000);
  
  // Create d tag for parameterized replaceable event
  const dTag = `${metric}-${language}-day-${timeframe.windowDays}-${timeframe.start}-${timeframe.end}-v1`;
  
  const tags: string[][] = [
    ['d', dTag],
    ['l', language],
    ['algo', 'lang=whatlang@0.16;act=all-kinds;elig=lifetime'],
    ['gran', 'day'],
    ['wdays', timeframe.windowDays.toString()],
    ['app', 'nostr-analytics/0.1.0']
  ];
  
  // Add relay tags
  for (const relay of relays) {
    tags.push(['r', relay]);
  }
  
  const content = JSON.stringify({
    version: 1,
    metric,
    language,
    relays,
    timeframe: {
      start: timeframe.start,
      end: timeframe.end,
      granularity: 'day',
      windowDays: timeframe.windowDays
    },
    counts: counts.map(c => [c.epoch_day, c.count]),
    eligibleUserCount,
    notes: `Generated by Nostr Analytics at ${new Date().toISOString()}`
  });
  
  return {
    created_at: now,
    kind: 30080,
    tags,
    content
  };
};

// Publish event to relays
export const publishToRelays = async (
  event: NostrEvent,
  relays: string[]
): Promise<void> => {
  const signedEvent = await signEvent(event);
  
  // Connect to relays and publish
  const promises = relays.map(async (relayUrl) => {
    try {
      const ws = new WebSocket(relayUrl);
      
      await new Promise<void>((resolve, reject) => {
        const timeout = setTimeout(() => {
          ws.close();
          reject(new Error(`Connection timeout: ${relayUrl}`));
        }, 10000);
        
        ws.onopen = () => {
          clearTimeout(timeout);
          // Send EVENT message
          ws.send(JSON.stringify(['EVENT', signedEvent]));
          
          // Wait a bit for confirmation
          setTimeout(() => {
            ws.close();
            resolve();
          }, 2000);
        };
        
        ws.onerror = () => {
          clearTimeout(timeout);
          ws.close();
          reject(new Error(`WebSocket error: ${relayUrl}`));
        };
      });
      
      console.log(`Published to ${relayUrl}`);
    } catch (error) {
      console.error(`Failed to publish to ${relayUrl}:`, error);
      throw error;
    }
  });
  
  await Promise.all(promises);
};

// Fetch published analytics results from relays
export const fetchPublishedResults = async (
  relays: string[],
  filters: {
    languages?: string[];
    metrics?: string[];
    since?: number;
    until?: number;
    authors?: string[];
  } = {}
): Promise<NostrEvent[]> => {
  const results: NostrEvent[] = [];
  const seenIds = new Set<string>();

  const promises = relays.map(async (relayUrl) => {
    return new Promise<void>((resolve) => {
      const ws = new WebSocket(relayUrl);
      let timeoutId: ReturnType<typeof setTimeout>;

      const cleanup = () => {
        clearTimeout(timeoutId);
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
          ws.close();
        }
      };

      timeoutId = setTimeout(() => {
        console.log(`Timeout fetching from ${relayUrl}`);
        cleanup();
        resolve();
      }, 30000);

      ws.onopen = () => {
        // Build filter for kind:30080
        const filter: any = {
          kinds: [30080]
        };

        if (filters.languages && filters.languages.length > 0) {
          filter['#l'] = filters.languages;
        }

        // Note: Metric filtering is done client-side since relays don't support prefix matching on d tags

        if (filters.since) {
          filter.since = filters.since;
        }

        if (filters.until) {
          filter.until = filters.until;
        }

        if (filters.authors && filters.authors.length > 0) {
          filter.authors = filters.authors;
        }

        const subscriptionId = Math.random().toString(36).substring(7);
        ws.send(JSON.stringify(['REQ', subscriptionId, filter]));

        console.log(`Fetching published results from ${relayUrl}`, filter);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data[0] === 'EVENT' && data[2]) {
            const nostrEvent = data[2];
            
            // Deduplicate by event ID
            if (!seenIds.has(nostrEvent.id)) {
              seenIds.add(nostrEvent.id);
              
              // Client-side filtering for metrics if needed
              if (filters.metrics && filters.metrics.length > 0) {
                const dTag = nostrEvent.tags.find((t: string[]) => t[0] === 'd')?.[1];
                if (dTag) {
                  const matchesMetric = filters.metrics.some(m => dTag.startsWith(`${m}-`));
                  if (matchesMetric) {
                    results.push(nostrEvent);
                  }
                }
              } else {
                results.push(nostrEvent);
              }
            }
          } else if (data[0] === 'EOSE') {
            cleanup();
            resolve();
          }
        } catch (error) {
          console.error(`Error parsing message from ${relayUrl}:`, error);
        }
      };

      ws.onerror = () => {
        console.error(`WebSocket error: ${relayUrl}`);
        cleanup();
        resolve();
      };

      ws.onclose = () => {
        cleanup();
        resolve();
      };
    });
  });

  await Promise.all(promises);
  
  console.log(`Fetched ${results.length} published results from ${relays.length} relay(s)`);
  return results;
};

// Parse published analytics event
export const parsePublishedResult = (event: NostrEvent): {
  metric: string;
  language: string;
  relays: string[];
  timeframe: {
    start: number;
    end: number;
    granularity: string;
    windowDays: number;
  };
  counts: [number, number][];
  eligibleUserCount: number;
  author: string;
  publishedAt: number;
} | null => {
  try {
    const content = JSON.parse(event.content);
    const lTag = event.tags.find((t: string[]) => t[0] === 'l')?.[1];
    const rTags = event.tags.filter((t: string[]) => t[0] === 'r').map((t: string[]) => t[1]);

    const metric = content.metric || 'unknown';
    const language = lTag || content.language || 'unknown';
    const author = event.pubkey || 'unknown';
    
    return {
      metric,
      language,
      relays: rTags.length > 0 ? rTags : (content.relays || []),
      timeframe: content.timeframe || { start: 0, end: 0, granularity: 'day', windowDays: 1 },
      counts: content.counts || [],
      eligibleUserCount: content.eligibleUserCount || 0,
      author,
      publishedAt: event.created_at
    };
  } catch (error) {
    console.error('Error parsing published result:', error);
    return null;
  }
};

