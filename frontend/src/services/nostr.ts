import { NostrEvent, NostrProvider, MetricDataPoint, MetricType } from '../types';
import { initWasm } from '../wasm/analytics';

// Storage key for private key
const PRIVATE_KEY_STORAGE = 'nostr-analytics-private-key';

// WASM module reference
let wasmModule: any = null;

// Initialize WASM module
const ensureWasmLoaded = async () => {
  if (!wasmModule) {
    await initWasm();
    wasmModule = await import('../wasm/pkg/nostr_analytics.js');
  }
  return wasmModule;
};

// Check if NIP-07 extension is available
export const isNostrAvailable = (): boolean => {
  return typeof window !== 'undefined' && !!window.nostr;
};

// Get stored private key
export const getStoredPrivateKey = (): string | null => {
  return localStorage.getItem(PRIVATE_KEY_STORAGE);
};

// Store private key
export const storePrivateKey = (privateKey: string): void => {
  localStorage.setItem(PRIVATE_KEY_STORAGE, privateKey);
};

// Clear stored private key
export const clearPrivateKey = (): void => {
  localStorage.removeItem(PRIVATE_KEY_STORAGE);
};

// Get public key from private key (hex) - using WASM
const getPublicKeyFromPrivate = async (privateKeyHex: string): Promise<string> => {
  const wasm = await ensureWasmLoaded();
  return wasm.get_public_key(privateKeyHex);
};

// Sign event with private key - using nostr-tools (WASM signing is async and complex)
const signEventWithPrivateKey = async (event: NostrEvent, privateKeyHex: string): Promise<NostrEvent> => {
  const { finalizeEvent } = await import('nostr-tools');
  
  const eventToSign = {
    ...event,
    pubkey: await getPublicKeyFromPrivate(privateKeyHex)
  };
  
  // Convert hex string to Uint8Array
  const secretKeyBytes = new Uint8Array(
    privateKeyHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
  );
  
  const signedEvent = finalizeEvent(eventToSign as any, secretKeyBytes);
  
  return signedEvent as NostrEvent;
};

// Get public key (from NIP-07 or stored private key)
export const getPublicKey = async (): Promise<string> => {
  // Try stored private key first
  const storedKey = getStoredPrivateKey();
  if (storedKey) {
    try {
      return await getPublicKeyFromPrivate(storedKey);
    } catch (error) {
      console.error('Failed to derive public key from stored private key:', error);
      clearPrivateKey();
    }
  }
  
  // Fall back to NIP-07
  if (!isNostrAvailable()) {
    throw new Error('Nostr extension (NIP-07) not found and no private key stored.');
  }
  
  try {
    return await window.nostr!.getPublicKey();
  } catch (error) {
    throw new Error(`Failed to get public key: ${error}`);
  }
};

// Sign event (using NIP-07 or stored private key)
export const signEvent = async (event: NostrEvent): Promise<NostrEvent> => {
  // Try stored private key first
  const storedKey = getStoredPrivateKey();
  if (storedKey) {
    try {
      return await signEventWithPrivateKey(event, storedKey);
    } catch (error) {
      console.error('Failed to sign with stored private key:', error);
      throw new Error(`Failed to sign event with private key: ${error}`);
    }
  }
  
  // Fall back to NIP-07
  if (!isNostrAvailable()) {
    throw new Error('Nostr extension (NIP-07) not found and no private key stored.');
  }
  
  try {
    return await window.nostr!.signEvent(event);
  } catch (error) {
    throw new Error(`Failed to sign event: ${error}`);
  }
};

// Create analytics result event (kind: 30080)
export const createAnalyticsEvent = (
  metric: MetricType,
  language: string,
  relays: string[],
  timeframe: {
    start: number;
    end: number;
    windowDays: number;
  },
  counts: MetricDataPoint[],
  eligibleUserCount: number
): NostrEvent => {
  const now = Math.floor(Date.now() / 1000);
  
  // Create d tag for parameterized replaceable event
  const dTag = `${metric}-${language}-day-${timeframe.windowDays}-${timeframe.start}-${timeframe.end}-v1`;
  
  const tags: string[][] = [
    ['d', dTag],
    ['l', language],
    ['algo', 'lang=whatlang@0.16;act=all-kinds;elig=lifetime'],
    ['gran', 'day'],
    ['wdays', timeframe.windowDays.toString()],
    ['app', 'nostr-analytics/0.1.0']
  ];
  
  // Add relay tags
  for (const relay of relays) {
    tags.push(['r', relay]);
  }
  
  const content = JSON.stringify({
    version: 1,
    metric,
    language,
    relays,
    timeframe: {
      start: timeframe.start,
      end: timeframe.end,
      granularity: 'day',
      windowDays: timeframe.windowDays
    },
    counts: counts.map(c => [c.epoch_day, c.count]),
    eligibleUserCount,
    notes: `Generated by Nostr Analytics at ${new Date().toISOString()}`
  });
  
  return {
    created_at: now,
    kind: 30080,
    tags,
    content
  };
};

// Publish event to relays
export const publishToRelays = async (
  event: NostrEvent,
  relays: string[]
): Promise<void> => {
  const signedEvent = await signEvent(event);
  
  // Connect to relays and publish
  const promises = relays.map(async (relayUrl) => {
    try {
      const ws = new WebSocket(relayUrl);
      
      await new Promise<void>((resolve, reject) => {
        const timeout = setTimeout(() => {
          ws.close();
          reject(new Error(`Connection timeout: ${relayUrl}`));
        }, 10000);
        
        ws.onopen = () => {
          clearTimeout(timeout);
          // Send EVENT message
          ws.send(JSON.stringify(['EVENT', signedEvent]));
          
          // Wait a bit for confirmation
          setTimeout(() => {
            ws.close();
            resolve();
          }, 2000);
        };
        
        ws.onerror = (error) => {
          clearTimeout(timeout);
          ws.close();
          reject(new Error(`WebSocket error: ${relayUrl}`));
        };
      });
      
      console.log(`Published to ${relayUrl}`);
    } catch (error) {
      console.error(`Failed to publish to ${relayUrl}:`, error);
      throw error;
    }
  });
  
  await Promise.all(promises);
};

